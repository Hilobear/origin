# 第1章  操作系统引论

## 1.1   OS的目标


**方便性:**

**有效性**:有效提高CPU和I/O设备利用率

​            合理地组织计算机的工作流程，从而改善资源的利用率和提高系统的吞吐量

**可扩展性:**

**开放性:**

### 1.3  操作系统的基本特征 

**1 、并发（Concurrence）**

**2 、共享（Sharing）** 

**3、虚拟（Virtual）** 

**4、 异步（Asynchronism）** 



### 1.4 操作系统的主要功能

**1.处理机管理功能**

处理机管理的主要功能：

  1） 创建和撤销进程   （进程控制）

   2）对诸进程的运行进行协调  （进程同步）

   3）实时进程间的信息交换  （进程通信）

   4）按照一定算法把处理机分配给进程  （进程调度）

**2.存储器管理功能**

存储器管理应具有以下功能：

   1）内存分配（静态、动态内存分配）

   2）内存保护（硬件检查越界，软件处理）

   3）地址映射（逻辑、物理地址，硬件支持）

   4）内存扩充（虚拟存储技术）

**3.设备管理功能**

主要任务：

   1）完成进程提出的I/O请求

   2）为用户分配其所需的I/O设备

   3）提高CPU和I/O的利用率

   4）提高I/O速度

   5) 方便用户使用I/O设备

**设备管理应具有以下功能：**

  1）缓冲管理---在设备和CPU之间引入缓冲，可有效地缓和CPU和I/O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统的吞吐量。

  2）设备分配

  3）设备处理---设备处理程序又称设备驱动程序

**4.文件管理功能**

主要任务： 

  对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性。

  文件管理应具有以下功能： 

​      1．文件存储空间的管理

​      2．目录管理

​      3．文件的读/写管理和保护 

**5.用户接口**

### 1.5  操作系统的结构设计

微内核**技术**---是指精心设计的、能实现现代OS最基本核心功能的小型内核。





# 第2章 进程的描述与控制

## 2.1  前趋图和程序执行

## 2.2 进程的描述 

##### **1.进程的定义和特征：**

**定义：**进程是程序在一个数据集上的运行过程，是系统进行资源分配和调度的一个独立单位。(传统OS的定义)

**进程的特征：**

1）结构特征：程序段、相关的数据段、PCB三部分构成了进程实体。

2）动态性：进程的本质是进程实体的一次执行过程，故动态性是进程的最基本特征。

3）并发性：这是指多个进程实体同存于内存，且能在一段时间同时运行。

4）独立性：在传统的OS中，独立性是指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。

5）异步性：是指进程按各自独立的、不可预知的速度向前推进，或说进程实体按异步方式运行。 

##### 2.进程的基本状态及转换

1）就绪（Ready）状态：当进程已分配到除CPU以外的所有资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。 

2）执行（Running）状态：进程已获得CPU,其程序正在执行。

3)  阻塞  (Blocked)  状态：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态（或等待状态）。 



##### 3、挂起操作及进程状态的转换

![](D:\picture\OS\进程挂起及状态转换.png)

##### 4.进程管理中的数据结构

**1）操作系统中用于管理控制的数据结构** 

资源信息表，进程管理表：

分类：内存表、设备表、文件表、进程表（进程控制块 PCB）

**2）PCB作用**

**3）进程控制块中的信息** 

**PCB**中记录了操作系统所需的、用于描述进程当前情况以及控制进程运行的全部信息。具体包括下述四方面的信息： 

A) 进程标识符：

B）处理机状态：

C）进程调度信息

D) 进程控制信息：

**4) 进程控制块的组织方式** 







### 2.3进程控制

#### 2.3.1操作系统内核

OS内核的功能：

​              1.支撑功能：中断处理、时钟管理、原语操作

​              2.资源管理功能：进程管理、存储器操作、设备管理

#### 2.3.2进程的创建

![](D:\picture\OS\进程的创建.png)

1.申请空白PCB。（pcb也有一定大小）

2.为新进程分配资源。主要是内存空间

3.初始化PCB。包括：

 4.将新进程插入就绪队列。



#### 2.3.3 进程的终止

#### 2.3.4 进程的阻塞和唤醒

**1.进程阻塞过程**

调用阻塞原语block把自己阻塞。（主动行为） 

阻塞（Blocked）过程：

![](D:\picture\OS\阻塞过程.png)

##### **2.进程唤醒过程**

调用唤醒原语wakeup()，将等待事件的进程唤醒。 

#### 2.3.5  进程的挂起和激活

**1.进程的挂起**

**挂起原语suspend()的执行过程：** 

 检查被挂起进程的状态：若处于活动或执行状态，则将其转为静止就绪；

​                                            若处于活动阻塞，则转为静止阻塞

把该进程的PCB复制到某指定内存区域

若该进程正在执行，则转向进程调度程序重新调度

**2.进程的激活**

原语active()的激活过程是：

将进程从外存调进内存；

检查该进程的现行状态：若是静止就绪，则改为活动就绪；

​                                          若是静止阻塞，则改为活动阻塞

若采用的是抢占是调度策略，则应检查被激活就绪进程的优先级，若其优先级比先行执行进程高，则应将处理机分配给激活进程。







### 2.4进程同步

#### 2.4.1进程同步的基本概念

**1.两种形式的制约关系**

**2.临界资源**

**3.临界区**

定义：每个进程中访问资源的那段代码称为临界区

进程互斥：不允许两个或两个以上的进程访问同一个临界资源

u在临界区前增加一段用于上述检查的代码，把这段代码称为进入区(entry section)

u在临界区后面也要加上一段称为退出区(exit section)的代码，用于将临界区正被访问的标志恢复为未被访问的标志。  

**4.进程机制应遵守的原则**

所有同步机制都应遵循如下四条准则： 

**空闲让进、忙则等待、有限等待、让权等待**

#### 2.4.2硬件同步机制

#### 2.4.3 信号量机制

**1.记录型信号量**



```c++
//定义记录型信号量的结构体
typedef struct{
   int value;
   struct PCB*list; //对应的进程或线程
}semaphore
//wait()函数,请求临界资源
wait(semaphore *S){//代表将要使用S资源，S--
   S->value--;
   if(S-value<0)block(S->list);//当资源不足时，阻塞当前进程或线程
}
//signal()函数，释放资源，若当前存在资源，则通知list中的PCB进行访问
signal(semaphore*S){
   S->value++;
   if(S-value>0)wakeup(S->list)//当有资源时，唤醒进程
}

```

**wait和signal操作的物理意义：**

**2.AND型信号量**

AND同步机制的基本思想：将进程在整个运行过程中需要的全部资源，一次性的分给进程，待使用完之后再一起释放。

```c++
//存在多个临界资源需要同时访问
Swait(S1,S2,...,Sn){
    while(true){
        if(S1->value>=1&&S2->value>=1&&...&&Sn->value>=1){
            for(int i=0;i<=n;i++) Si->value--;
            break;
        }
        else{
            //有一个临界资源不满足Si->value>1,请将队列中所有
        }
    }
}
//存在多个临界资源需要同时访问
Ssignal(S1,S2,...,Sn){
    while(true){
        for(int i=0;i<=n;i++){
            Si->value++;
            
        }
    }
}
```

**3.信号量集**

### 2.5  经典进程同步问题

#### 2.5.1生产者-消费者问题

**1.一个生产者、一个消费者、一个缓冲区的问题；**

★当缓冲区空时，生产者可将产品存入缓冲区；当缓冲区满时，生产者必须等待(阻塞)，待消费者取走产品后将其唤醒后，才能将产品存入。

★当缓冲区满时，消费者可从缓冲区取出产品进行消费；当缓冲区空时，消费者必须等待(阻塞)，待生产者存入产品后将其唤醒后，才能再从缓冲区取产品。

**用信号量机制解决进程同步问题的基本方法：**

   1.为生产者设置1个私有信号量empty，其初值为1，表示有1个空缓冲区；为消费者设置1个私有信号量full，其初值为0，表示开始时没有满缓冲区；（由物理意义确定）

  2.生产者将产品存入缓冲区之前，应先测试缓冲区是否空：执行wait(empty)操作；离开临界区(存入产品)后，应通知(可能会唤醒)消费者：执行signal(full)操作；

  3.消费者从缓冲区取产品之前，应先测试缓冲区是否满：执行wait(full)操作；离开临界区(取走产品)后，应通知(可能会唤醒)生产者：执行signal(empty)操作

```c++
semaphore empty,full;//定义两个信号量
empty.value=1;
full.value=0;
cobegin
//wait()函数,请求临界资源
wait(semaphore *S){
   S->value--;
   if(S-value<0)block(S->list);
}
//signal()函数，释放资源，若当前存在资源，则通知list中的PCB进行访问
signal(semaphore*S){
   S->value++;
   if(S-value>0)wakeup(S->list)
}
//生产者
process Producer:
{ ...
   produce an item in nextp;
   wait(empty);//测试
   buffer=nextp;   
   signal(full);//通知消费者，signal函数，首先对full->value++,然后
}
//消费者
process Consumer:
{
    wait(full); //测试，消费的是full，
    nextc=buffer;
    signal(empty); //通知
    consume the item  in nextc;
}
coend

```





##### 2.一个生产者，一个消费者、n个缓冲区的P-C问题

```c++
semaphore empty,full;
empty.value=n;   full.value=0;
int in=0,out=0;   //下标
cobegin
process Producer:
{ ...
   produce an item in nextp;
   wait(empty);//测试
   buffer[in]=nextp;
   in=(in+1)%n;
   signal(full);//通知消费者
}
process Consumer:
{
    wait(full); //测试
    nextc=buffer[out];
    out=(out+1)%n;
    signal(empty); //通知
    consume the item in nextc;
}
coend

```



##### 3.k个生产者、m个消费者、n个缓冲区的问题。



```c++
semaphore mutex,empty,full ;
item buffer[n] ;
int in = 0，out = 0 ；
mutex.value = 1;
empty.value = n，full.value = 0;

cobegin //并发执行开始 
process produceri (i=1,2,…,k）
{
     item nextp ；
     while （TRUE）
    {   …
       produce an item in nextp；
         …
  
      //如果先执行互斥信号量，此时成功后，在执行资源信号量，在执行资源互斥量时，进程可能被阻塞，此时互斥信号量已经进行--，会导致在高并发时，其他信号量不能对其进行访问，此时是两种的情况mutex
       Swait(empty,mutex);
       buffer[in] = nextp ；
       in = （in + 1）% n ；
       Ssignal(mutex,full);
     
   }
} 
process consumerj (j=1,2,…,m）
{  item nextc ；
    while （TRUE）
   {  
       Swait(full,mutex);
       nextc = buffer[out] ；
       out = （out + 1）% n ；
       Ssignal(mutex,empty);
       consume the item in nextc ；
    }
}
coend //并发执行结束 

```



总结：

**1.在进程同步时，为双方设置各自的信号量，初始值为其初始状态的资源数（资源信号量或私有信号量）；**

**2.同步双方任一进程在进入临界区之前，应先对自己的信号量执行wait(<己方信号量>)操作，以测试是否有自己可用的资源。若有资源可用，则进入临界区，否则阻塞；**

**3**.**同步双方任一进程离开临界区后，应对合作方(对方)的信号量执行signal(<对方信号量>)操作，以通知(若对方处于阻塞状态，则唤醒它)对方已有资源可用(对方已可进入临界区)。**







#### 2.5.2读者-写者问题

**算法分析：**

1.为实现Reader进程和Writer进程间的互斥，设置一个互斥信号**Wmutex**，其初值为1；

2.设置一个整型变量Rcounter，记录正在读的读者进程数。其初值为0；

3.由于只要有一个Reader进程在读，便不允许Writer进程去写，因此第一个读者进程需要执行wait（Wmutex）操作，即当Rcounter=0时，Reader进程才需要执行wait（Wmutex）操作。若wait（Wmutex）操作成功（表示此时无Writer进程在写），Reader进程便可去读，同时做Rcounter+1的操作。

4。同理，最后一个读进程Reader离开时，亦即计数变量Rcounter-1后变为0时，应执行signal(Wmutex)操作，以便让Writer进程写。

5.Rcounter是被多个Reader进程访问的临界资源，为了对它互斥访问，应为它设置一个互斥信号量**Rmutex**。 



```c++
//优先读者算法
semaphore Wmutex，Rmutex;
int  Rcounter = 0;
Wmutex.value=Rmutex.value=1; 

cobegin
//读
process Readeri (i = 1，2，…)
{
wait(Rmutex);//第一个读进程进入读进程访问区，
if(Rcounter==0) wait(Wmutex);//如果此时是第一个读进程，则开启锁，此时只允许读进程
Rcounter = Rcounter + 1;//增加一名读者数量
signal(Rmutex);//释放锁
…
Reading;
…
//对最后一个读进程进行判断
wait(Rmutex);//进入读进程
Rcounter = Rcounter – 1;//
if(Rcounter==0)signal(W  mutex);//最后一个读进程负责解锁
signal(Rmutex);//释放读进程
} 
//写
process Writerj (j=1，2，…)
{
    wait(Wmutex);
    Writing;
    signal(Wmutex);
}
coend 

“优先写者”的读者-写者问题可描述如下： 
semaphore Wmutex，Rmutex，w;
int  Rcounter = 0; w.value=1;
Wmutex.value=Rmutex.value=1; 
cobegin

process Readeri (i = 1，2，…)
{
wait(w);	//新增内容，为了封锁后续进程
wait(Rmutex);
if(Rcounter==0) wait(Wmutex);//第一个读者判断
Rcounter = Rcounter + 1;
signal(Rmutex);
signal(w);	//新增内容
…
Reading;
…
    ….
wait(Rmutex);
Rcounter = Rcounter – 1;
if(Rcounter==0)
    signal(Wmutex);
signal(Rmutex);
} 

process Writerj (j=1，2，…)
{
    wait(w);	//新增内容
    wait(Wmutex);
    Writing;
    signal(Wmutex);
    signal(w);	//新增内容
}
coend 





//优先写者算法

semaphore Wmutex=Wsem= 1；
semaphore Rmutex= Rsem1=Rsem2=1;
int  Rcounter = Wconuter = 0;
cobegin
process Reader_i (i = 1，2，…)
{
    //检查是否有写进程
    wait(Rsem2);//第一个写进程到达后的第一个读者在Rsem1上阻塞，其后  的读进程在Rsem2上阻塞
    wait(Rsem1);//检测当前是否有写进程，当存在写进程时，则等待
    
    wait(Rmutex);//互斥访问Rcounter
    Rcounter = Rcounter + 1;
    if(Rcounter==1) wait(Wsem);//当有读进程时，封锁写进程
    signal(Rmutex);//互斥访问Rcounter
    signal(Rsem1);
    signal(Rsem2);
    
    Reading( );
    
    //判断是不是最后一个读者
    wait(Rmutex);互斥访问Rcounter
    Rcounter = Rcounter - 1;
    if(Rcounter==0)signal(Wsem);//唤醒写进程
    signal(Rmutex);互斥访问Rcounter
} 
process Writer_j (j=1，2，…)
{
    //通过互斥访问Wcounter，判断当前是否要对后续读者进行封锁
    wait(Wmutex);//写进程互斥访问Wcounter
    Wcounter++;//判断是不是第一个写者
    if (Wcounter==1)//第一个写者，若是第一个写者，则封锁后续读者进程
       wait(Rsem1);//封锁后续读者
    signal(Wmutex);//释放写进程互斥访问Wcounter
    
   //检查是否存在读进程
    wait(Wsem);//检查是否有读进程。若没有，则开始写
    Writing( );
    signal(Wsem);//写完释放Wsem
    
    //检查是否为最后一个写进程
    wait(Wmutex);
    Wcounter=Wcounter-1;
    if (Wcounter==0) 
        signal(Rsem1);//解封后续读者
    signal(Wmutex);//退出写进程
}
coend

```



#### 2.5.3哲学家进餐问题



```c++
struct semaphore chopstick[5] ；
chopstick[0].value=chopstick[1].value=1;
chopstick[2].value=chopstick[3].value=1 ;
chopstick[4].value=1 ; 

cobegin
process  Pi（i = 0，1，2，3，4）
{
    while （TRUE）
    {  wait（chopstick[i]）；            //拿起左边筷子
        wait（chopstick[（i + 1）%5]）； //拿起右边筷子 
        eating ；
        signal（chopstick[i]）；         //放下左边筷子
        signal（chopstick[（i+1）%5]）；//放下右边筷子
        thinking ；
    }
}
coend 
```

上面代码可能导致死锁问题，当5个哲学家同时拿起左边筷子，此时都不能拿起右边筷子。

**对上述哲学家进餐算法的死锁问题，可采取下面几种解决方法之一：**

（1）至多允许4个哲学家同时取左边的筷子，这样能至少保证一个哲学家能就餐，并在用毕后释放他用过的两只筷子，从而使更多的哲学家能够进餐。

```c++
struct semaphore chopstick[5]，S ；
chopstick[0].value=chopstick[1].value=1;
chopstick[2].value=chopstick[3].value=1 ;
chopstick[4].value=1 ; 
S->value=4;

// 以下是5个哲学家进程代码的统一写法
process  Pi( ) (i = 0, 1, 2, 3, 4)  //第i个哲学家
 {    while (true) 
    {   
	  wait (S);      // 看看是否允许拿筷子
        wait (chopstick[i])；    //拿起左边筷子
        wait (chopstick[(i+1)%5])；//拿起右筷子 
        eating ；                  //吃面条
        signal (chopstick[i])；    //放下左边筷子
        signal (chopstick[(i+1)%5] //放下右边筷子
        signal (S);
        thinking ；                //思考
    }
} 
```

（2）仅当哲学家左右两只筷子均可用时，才允许他拿起筷子进餐。（用AND信号量机制）

```c++
// 以下是5个哲学家进程代码的统一写法
process  Pi( ) (i = 0, 1, 2, 3, 4)  //第i个哲学家
 {    while (true) 
    {   
	  
      
        Swait(chopstick[i],chopstick[i+1]); //同时拿起两只筷子
        eating ；                  //吃面条
        Swait(chopstick[i+1],chopstick[i])//同时放下两只筷子
       
        thinking ；                //思考
    }
} 
```

（3）规定奇数号哲学家先拿左边筷子，然后再拿右边筷子；而偶数号哲学家先拿右边筷子，然后再拿左边筷子。



（4）规定每个哲学家先拿序号小的筷子——按序号分配。



### 2.6进程通信



### 2.7线程

#### 2.7.1线程的引入

**进程**：既是资源分配的基本单位，又是调度和分配的基本单位。

#### 2.7.2  线程的与进程的比较

1、调度的基本单位

2、并发性

3、拥有资源

 4、独立性

 5、系统开销

6、支持多处理机系统

#### 2.7.3线程的状态和线程控制块





# 第3章  处理机调度与死锁

## 3.1处理机调度的层次

**1.高级调度**---又称作业调度或长调度

定义：用于决定把外存上后备队列中哪些作业调入内存，并为它们创建进程、分配必要的资源，然后将新创建的进程插入到就绪队列中，准备运行。

**2.低级调度**---又称进程调度或短调度

定义：用来决定就绪队列中的哪个进程应获得处理机，然后再由分派程序执行把处理机分配给该进程的具体操作。 

**3.中级调度**--又称内存调度，用于内外存的对换（挂起和激活）

目的：未来提高内存的利用率和系统的吞吐量

## 3.2调整队列模型和调度准则

具有三级调度的队列模型

![](D:\picture\OS\三级调度.png)

### 3.2.2处理机调度算法的目标

1处理机调度算法的共同目标

​     --资源利用率：特别是CPU利用率

​                               CPU利用率=

​    --公平性

​    --平衡性

​    --策略强制执行

2.批处理系统的目标

3.分时系统的目标

4.实时系统的目标



## 3.3调度算法

### 3.3.1先来先服务算法



### 3.3.2短作业（进程）优先算法

**短作业优先（SJF）调度算法**—— 从后备队列中选择一个或几个估计运行时间最短的作业，将它调入内存运行。

**短进程优先（SPF）调度算法**——从就绪队列中选择一个估计运行时间最短的作业，将处理机分配给它，使它立即执行并一直到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。(非抢占式) 

### 3.3.3高优先权优先调度算法

#### 1．优先权进程调度算法的类型

**非抢占式优先权算法**—— 系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直到完成，或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一个优先权最高的进程。 

**抢占式优先权算法**—— 系统把处理机分配给就绪队列中优先权最高的进程，使之执行，但在其执行期间，只要出现了另一个优先权更高的进程，系统就立即停止当前进程的执行，重新将处理机分配给新的优先权最高的进程。 

#### 2．优先权的类型

1）静态优先权

静态优先权——它是在创建进程时确定的，且在进程整个运行期间保持不变。

动态优先权——在创建进程时所赋予的优先权，可以随进程的推进，或随其等待时间的增加而改变，以便获得更好的调度性。 

.  
**高响应比优先调度算法：**（响应比实际上是动态优先权） 

**高响应比优先调度算法**——每次要进行作业调度时，系统首先计算后备队列中各作业的响应比，然后选择一个或若干个响应比最高的作业调入内存执行。 

响应比：（等待时间+要求服务时间）/ 要求服务时间

### 3.3.4基于时间片的轮转调度算法

1．时间片轮转法 

系统把就绪队列中的所有进程，按先来先服务的原则，排成一个队列；

每次调度时，把CPU分配给队首进程，并让它执行一个时间片； 

每当执行的时间片用完，调度程序便停止该进程的执行，将其送入就绪队列尾部；然后进行下一次进程调度。 

![](D:\picture\OS\时间片调度.png)



## 3.5 死锁概述

### 3.5.3 死锁的定义、必要条件和处理方法

#### **1.死锁的定义**：

如果一个进程集合中的每一个进程都在等待只能由该集合的其他一个进程才能引发的事件，则称一组进程或系统发生了死锁。



#### 2.发生死锁的四个必要条件：

  **1.互斥条件** 

  进程对所分配的资源进行排他性访问

  **2.请求和保持条件**

  进程由于请求新资源无法满足二阻塞时，不释放原先已保持的资源

  **3.不可抢占条件（不可剥夺条件）**

  进程已获得的资源在未使用完之前不能被抢占。

  **4.环路等待条件**  

  在发生死锁时，必然存在一个进程—资源的循环链



#### 3.死锁的处理方法

 **预防死锁，避免死锁，检测死锁，解除死锁**

**预防死锁**-------通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。缺点：可能导致系统资源利用率和系统吞吐量的降低。——较严格的限制条件 

**避免死锁**-------并不需要事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。目前在较完善的系统中，常用此方法来避免死锁。——只要较弱的限制条件

**检测死锁**------并不事先采取任何限制措施，也不必检查系统是否已经进入不安全区，允许系统在运行过程中发生死锁，但可通过系统设置的检测机构，及时检测出死锁的发生，然后采取适当的措施，从系统中将已发生的死锁清除掉。 

**解除死锁**--------这是与检测死锁相配套的措施。常用的方法是撤消或挂起一些进程，以便回收一些资源，分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。——实现上难度最大



## 3.6预防死锁

#### 1.破坏互斥条件

#### 2．破坏“请求并保持”条件 

协议1：资源的一次性分配（静态分配） 

协议2：进程可以在释放初期保持的资源后再次  申请新的资源

#### 3．破坏不可抢占条件

当一个进程保持了某些资源，再提出新的资源而不能满足时，必须释放已保持的资源，待以后再要时再重新申请。

#### 4．破坏“环路等待”条件 

采用资源“按号分配”

## 3.7 避免死锁 ---------银行家算法

### 1.安全状态

**安全状态**---系统能按某种进程顺序P1，P2，…，Pn（称<P1，P2，…，Pn>为安全序列），来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。 

**银行家算法：** 在资源动态分配的过程中，若分配后系统状态仍是安全的，则同意分配，否则拒绝分配，这样可防止系统进入不安全状态，从而避免死锁。

### 2.利用银行家算法避免死锁

**1）各种定义**

#### **可利用向量资源Available**

​    是一个含m个元素的数组，其中每一个代表一类资源数目，m是资源种类数

#### 最大需求矩阵Max

   是一个nxm矩阵，它定义了系统中n个进程的每一个进程对n类资源的最大需求数。

#### 分配矩阵Allocation

   也是一个nxm矩阵，它定义了系统中每一类资源当前分配给每一个进程的资源数。

#### 需求矩阵Need

也是一个nxm矩阵，用于表示每个进程尚需的各类资源数

![](D:\picture\OS\银行家算法.png)



**2）银行家算法步骤**     Requesti[j]  i代表第i个进程，j代表第j种资源

**设Requesti是进程Pi的请求向量，如果Requesti[j]＝K，表示进程Pi需要K个Rj类的资源。当Pi发出资源请求后，系统按下述步骤进行检查：**

①若Requesti[j]≤Need[i,j]，转向步骤②；否则认为出错，因为它需要的资源数已超过它所宣布的最大值。

②若Requesti[j]≤Available[j]，转向步骤③；否则表示尚无足够资源，Pi须等待。

③系统试探着把资源分配给进程Pi，并修改下面的数值：

```c++
Available[j] = Available[j] - Requesti[j] //可用资源
Allocation[i,j] = Allocation[i,j] + Requesti[j] //占领资源
Need[i,j] = Need[i,j] - Requesti[j]//
```

④系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才真正将资源分配给进程Pi，以完成本次分配；否则，将本次资源分配作废，恢复原来的资源分配状态，让进程Pi等待（阻塞）。

 **3）安全性算法** 

![](D:\picture\OS\安全性算法.png)



### 3.8死锁的检测



# 第四章 存储器管理





# 第五章  虚拟存储器



## 5.1 虚拟存储器的基本概念

### **虚拟存储器的基本原理如下：**

1**.部分装入**：应用程序运行前，没有必要将全部装入（局部性原理），

**2.请求调入**：程序运行时，如果所要访问的页（段）已调入内存，便可继续执行下去；否则，应利用OS所提供的请求调页（段）功能，将它们调入内存，以便继续运行。

**3.页/段置换**：如果此时内存已满，则需利用页（段）置换功能，将内存中暂不用的页（段）调到磁盘上再将访问的页（段）调入内存，使程序继续运行下去

虚拟存储器的特征：

1.多次性  请求调页

2.对换性  页面 **/** 段置换功能

3.虚拟性  

### 5.1.3 虚拟存储器的实现方法

**1、分页请求系统**

​    是在基本分页系统基础上，增加了**请求调页功能**和**页面置换功能**所形成的页式虚拟存储系统。

必须提供硬件支持和相应的软件：

硬件支持：

​       请求分页的页表机制

​        缺页中断机构

​       地址变换机构

实现请求分页的软件——请求调页、实现页面置换的软件

**2.请求分段系统**

是在基本分段系统基础上，增加了**请求调段功能**和**分段置换功能**所形成的段式虚拟存储系统。

硬件支持：

​       请求分段的段表机制

​        缺段中断机构

​       地址变换机构

实现请求分页的软件——请求调段、实现段置换的软件

## 5.2 请求分页存储管理方式

### 5.2.1  请求分页中的硬件支持

![](D:\picture\OS\1.png)

![](D:\picture\OS\2.png)



![](D:\picture\OS\3.png)



### 5.2.2 内存分配策略和分配算法

**为进程分配内存时，涉及到3个问题：**

1、最小物理块数的确定

  取决于指令的格式、功能和寻址方式  

2、物理块的分配策略 

​            固定分配局部置换

​            可变分配全局置换——最易于实现的物理块分配和置换策略，已用于若干OS中 

​            可变分配局部置换  

3、物理块分配算法

​           平均分配算法——显然不太合理

​            按比例分配算法 

​           考虑优先权的分配算法——一部分按比例；另一部分根据各进程的优先权——合理   

### 5.2.3 页面调入策略

## 5.3 页面置换算法

### 5.3.1最佳置换算法和先进先出置换算法

**1.最佳置换算法**

![](D:\picture\OS\最佳置换算法.png)

当内存（物理块）满之后，对内存于外村中的页或者块进行互换

**2.先进先出算法**

选择在内存中驻留时间最长的页面淘汰。设置一个指针，指向最老的页面。

![](D:\picture\OS\先进先出算法.png)



### 5.3.2 最近最久未使用（LRU）置换算法



### 5.3.3 Clock置换算法

**1.简单clock置换算法**

**当访问某页时，其访问位被置为1；**

当置换算法在选择淘汰某页时，检查页的访问位，若是1，则置为0，若为0则置换出去，若到最后一个还是1，则继续查找





**2.改进型Clock置换算法**

淘汰被修改过的页面时，需将其写回磁盘(置换代价高)，因此应淘汰既未被访问又未被修改的页面。为此，每个页面除了有**访问位A**外，还增加一个**修改位M**。由访问位A与修改位M可以组成下面4种类型的页面：

​       1类(A=0,M=0)，是最佳淘汰页；

​        2类(A=0,M=1) ；

​        3类(A=1,M=0) ；

​        4类(A=1,M=1) ，最近被访问且被修改过的页，最不应该淘汰。



(1) 从指针当前位置开始，扫描循环队列，寻找A=0且M=0的第1类页面，将所遇到的第一个页面淘汰。

(2) 若第1步查找一周后未遇到第1类页面，则寻找A=0且M=1的第2类页面，将所遇到的第一个页面淘汰。第2轮扫描中将所有扫描过的页面的访问位A清0。

(3)若第2轮扫描失败，则返回(1)，若仍失败，再重复第(2)步，此时就一定能找到被淘汰的页。



### 5.3.4 页面缓冲算法(PBA)



### 5.3.5 访问内存的有效时间

**设查找快表时间为λ,物理地址访问时间为t**

1.被访问页在内存中，其对应项在快表中

​        ETA =λ+ t

2.被访问页在内存中，其对应项不在快表中

​       ETA =2×(λ+ t)

3.被访问页不在内存中，设缺页中断处理时间ε

​      ETA =ε+2×(λ+ t)



## 5.4 “抖动”与工作集



## 5.5 请求分段存储管理方式


**1.段表机制**

![](D:\picture\OS\段表2.png)



增加了以下诸项：

**存取方式**：用于标识本分段的存取属性是执行、只读、读/写

**访问字段A**：用于记录该分段被访问的频繁程度

**修改位M**：用于表示该段进入内存后是否被修改，供分段置换时参考

**存在位P**：指示本段是否已调入内存，供程序访问时参考

**增补位**：用于表示该段进入内存后是否做过动态增长

**外存始址**：指示本段在外存中的起始地址，即起始盘块号

**2.缺段中断机构**

![](D:\picture\OS\缺段.png)



# 第六章  输入输出系统 

## 6.1 I/O系统的功能、模型和接口

I/O系统应具备以下几方面功能：

![](D:\picture\OS\IO功能.png)

对I/O设备进行控制

目前对I/O设备有四种控制方式：

① 采用轮询的可编程I/O方式；

② 采用中断的可编程I/O方式；

③ 直接存储器访问方式；

④ I/O通道方式。

具体采用何种控制方式，与I/O设备传输速率、传输的数据单位等因素有关。

![](D:\picture\OS\io层次.png)

**I/O系统中各模块之间的层次视图**

![](D:\picture\OS\6.png)

I/O系统的上、下接口

上层：**I/O接口**，向上层提供对设备进行操作的I/O抽象命令；

下层：**软件/硬件（RW/HW）接口**，连接中断处理程序与设备控制器

I/O系统的分层
与前面所述的I/O软件组织的层次结构相对应，I/O系统本身也可分为如下三个层次：
(1) 中断处理程序。
(2) 设备驱动程序。
(3) 设备独立性软件。

### 6.1.3 I/O系统接口

典型的设备接口有3类： 

  1. 块设备接口

  2. 流设备接口

  3.网络通信接口



## 6.2  I/O设备和设备控制器

### 6.2.1 I/O设备

数据信号线——设备和控制器之间传送数据。 

控制信号线——规定了设备要执行的操作。如，读、写、磁头移动等操作。 

状态信号线——指示设备当前的状态。如，正在读（或写）、读（写）完成等。

### 6.2.2  设备控制器

#### **1.作用**：

控制一个或几个I/O设备，实现I/O设备和计算机之间数据交换，它是CPU和I/O设备之间的接口。使处理机从繁杂的设备控制事物中解脱出来。

#### **2.设备控制器的基本功能：**

1.接受和识别命令

2.数据交换

3.标识和报告设备的状态

4.地址识别

5.数据缓冲

6.差错控制

#### **3.设备控制器的组成**

控制器组成：1.设备控制器与处理机的接口

​                        2.设备控制器与设备的接口

​                        I/O逻辑----用于对设备的控制



![](D:\picture\OS\设备控制器.png)



## 6.3　中断机构和中断处理程序

### 6.3.2  中断处理程序



**中断处理程序的处理步骤**

1.测定是否有未响应的中断信号

2.保护被中断进程的CPU环境

3.转入相应的设备处理程序

4.中断处理

5.恢复被中断进程的现场

## 6.4  设备驱动程序（通信和转换程序）

**设备驱动程序通常又称为设备处理程序**，它是I/O系统的高层与设备控制器之间的设备控制器之间的通信程序。

#### 1.设备驱动程序的功能

①接收由独立性软件发来的命令和参数，并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、磁道号和扇区号。

②检查用户I/O请求的合法性、了解I/O设备状态、传递有关参数、设置设备工作方式

③发出I/O命令。如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。

④及时响应由控制器或通道来的中断请求，并根据其中断类型调用相应的中断处理程序。

#### 2.设备驱动程序的特点

### 6.4.2 设备驱动程序的处理过程

设备驱动程序的主要任务是启动指定设备。但在启动之前，还必须完成必要的准备工作，如检查设备是否为“忙”等。在完成所有准备工作后，才最后向设备控制器发送一条启动命令。

以下是设备驱动程序的处理过程：

**(1)将抽象要求转换为具体要求**

**(2)检查I/O请求的合法性**

**(3)读出和检查设备的状态**

**(4)传送必要的参数**

**(5)启动I/O设备**

### 6.4.3  对I/O设备的控制方式

#### 1.用轮询的可编程I/O方式

#### 2.中断驱动可编程I/O方式



#### 3.直接存储器访问DMA控制方式

#####    1．DMA（Direct Memory Access）控制方式的引入 

   DMA组成：主机与DMA控制器的接口

​                       DMA控制器与块设备的接口

​                       I/O控制逻辑

#####   2.MDA的组成

![](D:\picture\OS\DMA的组成.png)

CR——命令/状态寄存器，用于接收从CPU发来的I/O命令或控制信息，或设备的状态。 

MAR——内存地址寄存器。 

DR——数据寄存器。暂存从设备到内存，或从内存到设备的数据。 

DC——数据计数器。要读或写的字节数。

##### 3．DMA工作过程 



#### 4.I/O通道控制方式

##### 1．I/O通道控制方式的引入 

使用DMA方式，CPU每发出一条I/O指令，只能读（或写）一个连续的数据块。

通道方式是DMA方式的发展。

##### 2．通道程序 

通道程序是由一系列通道命令（指令）所构成的。

通道是通过执行通道程序，并与设备控制器共同实现对I/O设备的控制的。



## 6.5  与设备无关的I/O软件



## 6.6 用户层的I/O软件



## 6.7   缓冲区管理

### 6.7.1  缓冲的引入

**引入缓冲的目的：** 

(1)缓和CPU与I/O设备间速度不匹配的矛盾

(2)减少对CPU的中断频率，放宽对CPU中断响应时间的限制。

(3)解决数据粒度不匹配的问题。

(4)提高CPU和I/O设备之间的并行性。

### 6.7.2 单缓冲和双缓冲

#### 1. 单缓冲 

在块设备输入时，假定：

从磁盘把一块数据输入到缓冲区的时间为T

操作系统将该缓冲区数据送到用户区的时间为M

CPU对这块数据处理（计算）时间为C

#### 2. 双缓冲

![](D:\picture\OS\双缓冲.png)



若C<T，因M<<T（使得块设备可以连续输入），系统处理一块数据的平均时间大约为Max(T,C)，可使块设备连续输入；

若C>T，（使得CPU可以不用等待设备输入）系统处理一块数据的平均时间大约为C+M，即M+Max(T,C),可使进程不必等待设备（CPU可以不停地计算） 



### 6.7.3 环形缓冲区（循环缓冲）

#### 1．环形缓冲的组成 

![](D:\picture\OS\环形缓冲区.png)

1）多个缓冲区。可分3类：

​           空缓冲区R

​           满缓冲区G

​           现行缓冲区C——正在使用的

（2）多个指针。有3种：

​           指针Nextg——指示计算进程下一个可用缓冲区G（满缓冲区）

​           指针Nexti——指示输入进程下次可用缓冲区R（空缓冲区）

​           指针Current——指示计算进程正在使用的缓冲区C

#### 2．环形缓冲区的使用

##### （1）Getbuf过程 

计算进程要使用缓冲区时，调用Getbuf过程：将Nextg所指的缓冲区改为“现行”，用Current指向它，同时将Nextg指向下一个G缓冲区。

输入进程要使用缓冲区时，调用Getbuf过程：将Nexti所指的缓冲区供给输入进程使用，同时将Nexti指向下一个R缓冲区。

##### （2）Releasebuf过程 

计算进程把C缓冲区的数据提取完毕时，调用Releasebuf过程，将缓冲区G释放：将该缓冲区由现行缓冲区C改为空缓冲区R。

输入进程把缓冲区装满时，调用Releasebuf过程，将该缓冲区释放，并改为满缓冲区G。  

#### 3．环形缓冲区——进程同步

Nexti指针追上Nextg指针。已无空缓冲区，输入进程阻塞——计算进程在Releasebuf时唤醒它。

Nextg指针追上Nexti指针。计算进程快，已无满缓冲区。计算进程阻塞，直到输入进程用Releasebuf时唤醒它。





### 6.7.4 缓冲池



## 6.8 磁盘存储器的性能和调度

### 6.8.1 磁盘访问时间

**1）寻道时间Ts:**是指把磁臂（磁头）移动到指定磁道上所经历的时间。

**2）旋转延迟时间Tr：**是指定扇区移动到磁头下面所经历的时间。 

**3）传输时间Tt :**是指把数据从磁盘上读出或向磁盘写入数据所经历的时间。



### 6.8.2 磁盘调度

#### 1．先来先服务（FCFS）



#### 2．最短寻道时间优先SSTF 



### 6.8.3 基于扫描的磁盘调度算法

#### 1．扫描（SCAN）算法——电梯算法 



#### 2．循环扫描（CSCAN）算法——单向扫描 



# 第七章  文件管理

## 7.1  文件和文件系统

文件是指具有文件名的若干相关元素的集合。

元素通常是记录，

记录又是一组有意义的数据项的集合。

### 7.1.1 数据项、记录和文件

#### 1.数据项

基本数据项

组合数据项

#### 2.记录

记录是一组相关数据项的集合，用于描述一个对象在某方面的属性。

一个记录应包含哪些数据项，取决于需要描述对象的哪个方面。由于对象所处的环境不同可把他作为不同的对象。

#### 3.文件

文件是指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种。


![](D:\picture\OS\文件.png)



### 7.1.2 文件名和类型



### 7.1.3 文件系统的层次结构

文件系统模型分为三个层次：

​       **1.底层是对象及其属性**——文件、目录、磁盘存储空间

​         **文件**：文件本身，文件管理的直接对象。

​         **目录**：方便用户对文件存取和检索。

​         **磁盘(磁带)存储空间**：文件在磁盘中占用的空间，有些的存储管理可以提高外存的利用率，提高文件的存取速度。

​       **2.中间层是对对象进行操纵和管理的软件集合**：对文件存储空间的管理、对文件目录的管理、用于将文件的逻辑地址转换为物理地址的机制、对文件读、写的管理、对文件的共享和保护等功能——文件系统的核心部分

​     

​    **3.高层是文件系统提供给用户的接口**——命令接口、程序接口  



### 7.1.4 文件操作

当前OS所提供的大多数文件操作，其过程大致都是这样两步：

​       1.通过检索文件目录来找到指定文件的属性及其在外存上的位置；

​       2. 文件实施相应的操作，如读文件或写文件等。

打开文件——是指系统将指明文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件表的一个表目中，并将该表目的编号（或称索引号）返回给用户。



## 7.2  文件的逻辑结构

#### 文件的逻辑结构



#### 文件的物理结构

##### 根据用户和系统管理上的需要，可采用多种方式来组织这些记录，形成下述几种文件：

**顺序文件**

**索引文件**

**哈希文件**



## 7.3  文件目录

为了能对文件进行正确的存取，必须为文件设置用于描述和控制文件的数据结构，称为“**文件控制块（FCB）**”。 

一个**文件**对应一个**FCB（目录项）**。若干目录项组成一个目录文件。

#### 1．文件控制块

通常包含三类信息：

**基本信息类**

①文件名；

②文件物理位置；

③文件逻辑结构；

④文件物理结构 

**存取控制信息类**

①文件主的存取控制权限；

②核准用户的存取控制权限；

③一般用户的存取控制权限


**使用信息类**

①文件建立的日期、时间；

②文件上一次修改的日期、时间；

③当前使用信息：已打开文件的进程数；是否被其他用户锁住；文件在内存中是否已被修改但尚未拷贝到磁盘上

#### 2.索引结点

##### 1.索引的引入

UNIX采用索引结点，每个目录项占16B，其中14B为文件名，2B为i结点指针（索引结点号）

这样使得PCCB变小，索引节点来存储更多信息；

##### 2.磁盘索引结点



##### 3.内存索引结点



### 7.3.2 目录结构 



## 7.4  文件共享



## 7.5  文件保护



# 第八章 磁盘存储器的管理

## 8.1  外存的组织方式

文件的物理结构直接与外存的分配（组织）方式有关。

目前常用的外存分配方式有：

​    **连续分配**：为每个文件分配一片连续的磁盘空间。

​      

​    **链接分配**：为每个文件分配不连续的磁盘空间，用指针将所有盘块连接起来。

​    **索引分配**：为每个文件分配一个索引块(表)，把分配给该文件的盘块号都记录在索引块中。











## 8.2  文件存储空间的管理

为实现存储空间的分配，系统必须记住存储空间的使用情况。为此，需

​          **设置相应的数据结构；**

​          **提供存储空间分配和回收的手段。**

### 8.2.1 空闲表法和空闲链表法

#### 1．空闲表法

为外存上的所有空闲表建立一张空闲表，每个空闲区对应一个空闲项目表。

空闲项目表包括：表项序号，该空闲区第一块盘号，空闲块数

![](D:\picture\OS\空闲表法.png)



**2）存储空间的分配和回收**



#### 4.空闲链表法 

将所有空闲区拉成一条空闲链。可有两种形式：**空闲盘块链**、**空闲盘区链**

1）空闲盘块链

​    将空闲空间，以盘块为单位拉成一条链。

优点：分配回收简单

缺点：为一个文件分配盘块时，可能要重复操作多次。

2）空闲盘区链

​    将所有空闲盘区拉成一条链。 

每个结点中除了指针外，还应指明盘区大小。分配方法与内存动态分区分配类似。可以采用显式链接。



### 8.2.3 成组链接法 

#### 1．空闲盘块的组织

**1）空闲盘块号栈。**

















































































































## 8.3  提高磁盘I/O速度的途径

## 8.4  提高磁盘可靠性的技术

## 8.5  数据一致性控制







